# dhcpd.conf for interface __INTERFACE__
# generated by dyndhcpd/__VERSION__

authoritative;
ddns-update-style none;
ignore client-updates;
default-lease-time 21600;
max-lease-time 43200;

option domain-name "__DOMAINNAME__";

subnet __NETADDRESS__ netmask __NETMASK__ {
	option broadcast-address __BROADCAST__;
	option routers __ADDRESS__;
	option domain-name-servers __ADDRESS__;
	option time-servers __ADDRESS__;

	range dynamic-bootp __MINHOST__ __MAXHOST__;
}

# make sure we do not serve our own address
host localhost {
	hardware ethernet de:ad:00:be:ef:00;
	fixed-address __ADDRESS__;
}

include "/etc/dyndhcpd/ipxe-options.conf";

class "PXEClient" {
	match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";

	allow booting;
	allow bootp;

	next-server __ADDRESS__;

	# Disable ProxyDHCP, we're in control of the primary DHCP server.
	option ipxe.no-pxedhcp 1;

	# Make sure the iPXE we're loading supports what we need,
	# if not load a full-featured version.
	if exists ipxe.http
	  and exists ipxe.menu
	  and ((exists ipxe.pxe
	      and exists ipxe.bzimage
	      and exists ipxe.elf)
	    or (exists ipxe.efi)) {
		# Everything is fine, just send the boot configuration file.
		filename "http://__ADDRESS__:3928/default.ipxe";
	} elsif exists user-class and option user-class = "iPXE" {
		# We're already using iPXE, but not a feature-full version,
		# and possibly an out-of-date version from ROM, so load a more
		# complete version with native drivers.
		if option arch = 00:06 {
			filename "/ipxe/efi-i386.efi";
		} elsif option arch = 00:07 {
			filename "/ipxe/efi-x86_64.efi";
		} else {
			filename "/ipxe/ipxe.pxe";
		}
	} elsif exists user-class and option user-class = "gPXE" {
 		# If someone has an old version of gPXE burned into their ROM,
		# load a more recent iPXE
		filename "/ipxe/ipxe.pxe";
	} elsif option arch = 00:06 {
		filename "/ipxe/efi-i386.efi";
	} elsif option arch = 00:07 {
		filename "/ipxe/efi-x86_64.efi";
	} else {
		filename "/ipxe/ipxe.pxe";
	}
}
